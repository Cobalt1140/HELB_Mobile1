package com.example.helb_mobile1.managers;

import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.NonNull;

import com.example.helb_mobile1.managers.db_callbacks.ICurrentTimeCallback;
import com.example.helb_mobile1.managers.db_callbacks.IDailyWordCallback;
import com.example.helb_mobile1.managers.db_callbacks.ILeaderboardCallback;
import com.example.helb_mobile1.managers.db_callbacks.IMarkerListCallback;
import com.example.helb_mobile1.managers.db_callbacks.IPersonalMarkerCallback;
import com.example.helb_mobile1.managers.db_callbacks.ISubmitMarkerCallback;
import com.example.helb_mobile1.managers.db_callbacks.IUserDataCallback;
import com.example.helb_mobile1.managers.db_callbacks.IUsernameCallback;
import com.example.helb_mobile1.models.UserScore;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;

import java.time.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DatabaseManager {
    /*
    Manager for everything related directly to the Firebase Realtime Database
    https://firebase.google.com/docs/database/android/start
     */

    public static final String DB_USERNAME = "username";
    public static final String DB_MARKER_LAT = "lat";
    public static final String DB_MARKER_LNG = "lng";

    //Coordinates for the center of the Plaine Campus
    public static final double CENTER_POINT_BOUNDARY_LAT = 50.81973292056924;
    public static final double CENTER_POINT_BOUNDARY_LNG = 4.399286094121766;


    private static final int DB_NUMBER_OF_TOP_USERS = 25;
    private static final String DB_DAILY_WORD = "dailyWord";
    private static final String DB_WORD = "word";
    private static final String DB_MARKER_LIST = "markerList";
    private static final String DB_USER_PROFILE = "userProfiles";
    private static final String DB_POINT_TOTAL = "pointTotal";
    private static final String DB_POINT_DAILY = "dailyPoints";
    private static final String DB_MARKER_TIMESTAMP = "timestamp";
    private static final double BOUNDARY_MAX_DISTANCE = 350.0; // Allowed range
    private static final String DB_URL = "https://helbmobile1-default-rtdb.europe-west1.firebasedatabase.app/";


    private final FirebaseDatabase db;
    private static DatabaseManager instance; //singleton
    /*
    DB Structure
    - userProfiles
        - <uid>
            - username <String>
            - pointTotal <int>
            - dailyPoints <int>


    - dailyWord
        - word <String>
        - markerList
            - <uid>
                - username
                - lat
                - lng
                - timestamp
     */


    private DatabaseManager(){
        //DatabaseManager can only be accessed through getInstance, as it is a singleton
        db = FirebaseDatabase.getInstance(DB_URL);
    }

    public static synchronized DatabaseManager getInstance(){
        if (instance == null) {
            instance = new DatabaseManager();
        }
        return instance;
    }

    public void createUserProfile(String uid, String username) {
        /*
        Creates a new UserProfile in the DB with a given uid and username
         */
        DatabaseReference userRef = db.getReference(DB_USER_PROFILE).child(uid);

        Map<String, Object> userData = new HashMap<>();
        userData.put(DB_USERNAME, username);
        userData.put(DB_POINT_TOTAL, 0);
        userRef.setValue(userData);
    }


    public void handleIsUsernameTaken(String usernameToCheck, ValueEventListener listener) {
        /*
        allows to put in a listener to handle what happens if a username is already taken in the UserProfiles
        Code generated by ChatGPT, modified
         */
        DatabaseReference usersRef = db.getReference(DB_USER_PROFILE);
        usersRef.orderByChild(DB_USERNAME)
                .equalTo(usernameToCheck)
                .addListenerForSingleValueEvent(listener);
    }


    public void submitMarker(String uid, double lat, double lng, ISubmitMarkerCallback callback) {
        /*
        method for submitting a marker to the DB
        uid to verify username of the user
        lat and lng for the coordinates of the marker to submit
        callback in parameter to allow to trigger code in different situations
         */
        handleIfWithinTimeWindow(TimeConfig.NEW_WORD_TIME_HOUR, TimeConfig.PUBLISH_TIME_HOUR, new ICurrentTimeCallback() {
            //gives callbacks to handle if attempting to submit marker when it's not Publishing Time
            @Override
            public void onTimeCheckFailed(String message) {
                callback.onError("Problem checking time on server: "+message);
            }

            @Override
            public void onWithinTimeWindow(int time) {
                //Boundary check to see if user is close to the center boundary point (Plaine Campus)

                Log.d("DatabaseManager","Submit marker, à l'intérieur ("+TimeConfig.PUBLISH_TIME_HOUR+"h-"+
                        TimeConfig.NEW_WORD_TIME_HOUR+" Current time: "+time+"h");

                double distance = haversineDistance(lat, lng, CENTER_POINT_BOUNDARY_LAT, CENTER_POINT_BOUNDARY_LNG);
                if (distance > BOUNDARY_MAX_DISTANCE) {
                    callback.onError("Vous êtes en dehors de la distance autorisée pour soumettre un marqueur\n Veuillez vous approchez du centre du campus de la Plaine.");
                    return;
                }



                fetchAndHandleUsernameWithUid(uid, new IUsernameCallback() {
                    //fetches the username of the user with the given uid so as to make sure no errors happen with cached usernames
                    @Override
                    public void onSuccess(String username) {

                        DatabaseReference markerRef = db.getReference(DB_DAILY_WORD)
                                .child(DB_MARKER_LIST)
                                .child(uid);
                        //creates marker data
                        Map<String, Object> markerData = new HashMap<>();
                        markerData.put(DB_MARKER_LAT, lat);
                        markerData.put(DB_MARKER_LNG, lng);
                        markerData.put(DB_USERNAME, username);
                        markerData.put(DB_MARKER_TIMESTAMP, System.currentTimeMillis());

                        //submits marker to the DB marker List
                        markerRef.setValue(markerData)
                                .addOnSuccessListener(task -> callback.onSuccess())
                                .addOnFailureListener(e -> callback.onError(e.getMessage()));
                    }

                    @Override
                    public void onError(String error) {
                        callback.onError("Erreur pour récupérer le nom d'utilisateur: " + error);
                    }
                });
            }

            @Override
            public void onOutsideTimeWindow(int time) {
                callback.onError("En dehors de la fenêtre horaire ("+TimeConfig.NEW_WORD_TIME_HOUR+"-"+TimeConfig.PUBLISH_TIME_HOUR+")\n Heure actuelle: "+time);
            }
        });

    }


    public void fetchAndHandleAccountData(String uid, IUserDataCallback callback) {
        /*
        fetches user's account data with given uid, such as their username and global points, to display in Account Fragment
        callback in parameter to allow to trigger code in different situations
         */
        DatabaseReference userRef = db.getReference(DB_USER_PROFILE).child(uid);
        userRef.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                //takes a snapshot of the database from the DatabaseReference when fetched to get data from
                String username = snapshot.child(DB_USERNAME).getValue(String.class);
                long points = snapshot.child(DB_POINT_TOTAL).getValue(Long.class);
                callback.onUserDataReceived(username, points);
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                callback.onError(error.getMessage());
            }
        });
    }

    public void fetchAndHandleLeaderboard(Boolean isTrueDailyFalseGlobal, ILeaderboardCallback callback){
        /*
        fetches user scores for leaderboard use
        isTrueDailyFalseGlobal is to handle which ordering we want to give the list for the callback
        (True = Daily = Ordered descending from scores in DailyPoints; False = Global =Ordered descending from scores in pointTotal)
        callback in parameter to allow to trigger code in different situations
         */
        DatabaseReference usersRef = db.getReference(DB_USER_PROFILE);

        String dailyOrGlobal;
        if (isTrueDailyFalseGlobal){ //true for Daily
            dailyOrGlobal = DB_POINT_DAILY;
        } else { // false for Global
            dailyOrGlobal = DB_POINT_TOTAL;
        }
        //Code suggested by ChatGPT
        usersRef.orderByChild(dailyOrGlobal)
                .limitToLast(DB_NUMBER_OF_TOP_USERS) //only gets the top users
                .addListenerForSingleValueEvent(new ValueEventListener() {
                    @Override
                    public void onDataChange(@NonNull DataSnapshot snapshot) {
                        //takes a snapshot of the database from the DatabaseReference when fetched to get data from

                        List<UserScore> userScores = new ArrayList<>(); //new Ordered List for ranking of Users, using UserScore data Model

                        for (DataSnapshot userSnap : snapshot.getChildren()) {
                            String username = userSnap.child(DB_USERNAME).getValue(String.class);
                            Long score = userSnap.child(dailyOrGlobal).getValue(Long.class);

                            if (username != null) {
                                userScores.add(new UserScore(username, score != null ? score : 0));
                            }
                        }
                        Collections.reverse(userScores); //the list is ordered ascending, so reverse for descending
                        callback.onSuccess(userScores);
                    }

                    @Override
                    public void onCancelled(@NonNull DatabaseError error) {
                        callback.onError(error.getMessage());
                    }
                });
    }

    public void fetchAndHandleDailyWord(IDailyWordCallback callback){
        /*
        fetches the Daily Word from the database
        callback in parameter to allow to trigger code in different situations
         */
        DatabaseReference wordRef = db.getReference(DB_DAILY_WORD);
        wordRef.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                //takes a snapshot of the database from the DatabaseReference when fetched to get data from
                String dailyWord = snapshot.child(DB_WORD).getValue(String.class);
                callback.onDailyWordFound(dailyWord);
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                callback.onError(error.getMessage());
            }
        });

    }

    public void fetchAndHandlePersonalMarker(String targetUid, IPersonalMarkerCallback callback){
        /*
        fetches the user's personal marker from the database using the given uid
        callback in parameter to allow to trigger code in different situations
         */
        DatabaseReference markersRef = db.getReference(DB_DAILY_WORD).child(DB_MARKER_LIST);
        markersRef.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                ////takes a snapshot of the database from the DatabaseReference when fetched to get data from
                for (DataSnapshot markerSnap : snapshot.getChildren()) { //foreach marker
                    String uid = markerSnap.getKey();

                    if (uid != null && uid.equals(targetUid)) {
                        Map<String, Object> markerData = new HashMap<>();
                        markerData.put(DB_MARKER_LAT, markerSnap.child(DB_MARKER_LAT).getValue(Double.class));
                        markerData.put(DB_MARKER_LNG, markerSnap.child(DB_MARKER_LNG).getValue(Double.class));
                        markerData.put(DB_MARKER_TIMESTAMP, markerSnap.child(DB_MARKER_TIMESTAMP).getValue(Long.class));
                        markerData.put(DB_USERNAME, markerSnap.child(DB_USERNAME).getValue(String.class));
                        callback.onUserMarkerFound(uid, markerData);
                        return;
                    }
                }
                callback.onNoPersonalMarker(); //callback for if user has not set a personal marker in DB

            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                callback.onError("Erreur connexion à la DB: "+error.getMessage());
            }
        });
    }

    public void fetchAndHandleMarkerList(String targetUid, IMarkerListCallback callback){
        /*
        fetches the MarkerList from the DB
        distinguishes the user's personal marker by using the given uid
        callback in parameter to allow to trigger code in different situations
         */
        handleIfWithinTimeWindow(TimeConfig.PUBLISH_TIME_HOUR, TimeConfig.NEW_WORD_TIME_HOUR, new ICurrentTimeCallback() {
            //gives callbacks to handle if attempting to fetch Marker List when it's not Results Time
            @Override
            public void onTimeCheckFailed(String message) {
                callback.onError("Erreur vérification du temps: "+message);
            }

            @Override
            public void onWithinTimeWindow(int time) {
                Log.d("DatabaseManager","MarkerList, A l'intérieur de plage horaire ("+TimeConfig.PUBLISH_TIME_HOUR+"h-"+
                        TimeConfig.NEW_WORD_TIME_HOUR+"h) current time: "+time+"h");
                DatabaseReference markersRef = db.getReference(DB_DAILY_WORD).child(DB_MARKER_LIST);
                markersRef.addListenerForSingleValueEvent(new ValueEventListener() {
                    @Override
                    public void onDataChange(@NonNull DataSnapshot snapshot) { //snapshot is list of all markers
                        //takes a snapshot of the database from the DatabaseReference when fetched to get data from
                        //Code suggested by ChatGPT, modified
                        Map<String, Map<String, Object>> allMarkers = new HashMap<>(); //Map of all markers and their creator's uid
                        for (DataSnapshot markerSnap : snapshot.getChildren()) { //foreach marker
                            String uid = markerSnap.getKey();
                            Map<String, Object> markerData = new HashMap<>();
                            //creates a marker with lat and lng coordinates, the timestamp of when it was created and the creator's username

                            markerData.put(DB_MARKER_LAT, markerSnap.child(DB_MARKER_LAT).getValue(Double.class));
                            markerData.put(DB_MARKER_LNG, markerSnap.child(DB_MARKER_LNG).getValue(Double.class));
                            markerData.put(DB_MARKER_TIMESTAMP, markerSnap.child(DB_MARKER_TIMESTAMP).getValue(Long.class));
                            markerData.put(DB_USERNAME, markerSnap.child(DB_USERNAME).getValue(String.class));
                            if (uid != null && uid.equals(targetUid)) {
                                callback.onUserMarkerFound(uid, markerData); //callback for when the user's marker is found, do different callback for this
                            } else {
                                allMarkers.put(uid, markerData);
                            }
                        }
                        callback.onMarkersFetched(allMarkers); //callback for the whole list of markers from DB (except user Marker if found)
                    }

                    @Override
                    public void onCancelled(@NonNull DatabaseError error) {
                        callback.onError("Erreur connexion DB: "+error.getMessage());
                    }
                });
            }

            @Override
            public void onOutsideTimeWindow(int time) {
                callback.onError("En dehors de la fenêtre horaire ("+TimeConfig.PUBLISH_TIME_HOUR+"h-"+
                        TimeConfig.NEW_WORD_TIME_HOUR+"h)\nHeure actuelle: "+time+"h");
                Log.d("DatabaseManager","MarkerList, En dehors de la fenêtre horaire ("+TimeConfig.PUBLISH_TIME_HOUR+"h-"+
                        TimeConfig.NEW_WORD_TIME_HOUR+" Current time: "+time+"h");
            }
        });

    }

    private double haversineDistance(double lat1, double lon1, double lat2, double lon2) {
        /*
        formula to calculate distance between two coordinates (lat1,lng1) - (lat2,lng2)
        Code generated by ChatGPT
         */
        final int R = 6371000; // Radius of the Earth in meters
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // Distance in meters
    }

    private void fetchAndHandleUsernameWithUid(String uid, IUsernameCallback callback){
        /*
        fetches a user's username with the given uid, so as to not rely on cached data
        callback in parameter to allow to trigger code in different situations
         */
        DatabaseReference userRef = db.getReference(DB_USER_PROFILE).child(uid);
        userRef.child(DB_USERNAME).addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                //takes a snapshot of the database from the DatabaseReference when fetched to get data from
                String username = snapshot.getValue(String.class);
                if (username != null) {
                    callback.onSuccess(username);
                } else {
                    callback.onError("Nom d'utilisateur pas trouvé avec UID: " + uid);
                }
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                callback.onError("Erreur connexion DB: "+error.getMessage());
            }
        });
    }

    private void handleIfWithinTimeWindow(int startHour, int endHour, ICurrentTimeCallback callback) {
        /*
        gets the difference between the system's clock and the server's clock
        compares this value to startHour and endHour to see if user is within time window
        gives different callbacks to handle if the user is or isn't in the time window
        this method assures the user cannot trick the app by changing their system clock
        Code suggested by ChatGPT, modified
         */

        db.goOffline(); //we reconnect to the database to get a fresh time offset
        db.goOnline();
        DatabaseReference offsetRef = db.getReference(".info/serverTimeOffset");
        new Handler(Looper.getMainLooper()).postDelayed(() -> { //as the reconnection is asynchronous, give a delay before executing rest of code, generated by ChatGPT
            offsetRef.addListenerForSingleValueEvent(new ValueEventListener() {
                @Override
                public void onDataChange(@NonNull DataSnapshot snapshot) {
                    //takes a snapshot of the database from the DatabaseReference when fetched to get data from
                    Long offset = snapshot.getValue(Long.class);
                    Log.d("DatabaseManager", "Offset: " + offset);
                    if (offset == null) {
                        callback.onTimeCheckFailed("Erreur");
                        return;
                    }
                    long estimatedServerTimeMs = System.currentTimeMillis() + offset;
                    Log.d("DatabaseManager", "EstimatedServerTime: " + estimatedServerTimeMs);
                    ZonedDateTime belgianTime = Instant.ofEpochMilli(estimatedServerTimeMs)
                            .atZone(ZoneId.of(TimeConfig.SERVER_TIMEZONE));
                    int currentHour = belgianTime.getHour();

                    boolean inWindow;
                    if (startHour < endHour) { //handles if start hour is higher than end hour, so that Day Change is accounted for
                        inWindow = currentHour >= startHour && currentHour < endHour;
                    } else {
                        inWindow = currentHour >= startHour || currentHour < endHour;
                    }

                    if (inWindow) {
                        callback.onWithinTimeWindow(currentHour);
                    } else {
                        callback.onOutsideTimeWindow(currentHour);
                    }
                }

                @Override
                public void onCancelled(@NonNull DatabaseError error) {
                    callback.onTimeCheckFailed(error.getMessage());
                }
            });
        }, 500);
    }




}
